load generator

mod LOGIC-CORE is
    protecting CONVERSION .

    protecting LOGIC-STACK .
    protecting GENERATOR .
    protecting SETS .

    sorts Instr Block .

    ops call branch goto fail : -> Instr [ctor] .
    ops fresh nonvar isvar unif dif : -> Instr [ctor] .
    ops swap pop rot dup : -> Instr [ctor] .
    ops lt lte add sub mul mod : -> Instr [ctor] .
    op choose : -> Instr [ctor] .
    op chooseDeps : VarList -> Instr [ctor] .
    op v : Qid -> Instr [ctor] .
    op str : String -> Instr [ctor] .
    op lbl : Qid -> Instr [ctor] .
    op int : Int -> Instr [ctor] .
    op nth : Int -> Instr [ctor] .
    op functor : Qid Nat -> Instr [ctor] .

    ops emptyset subset singleton union intersection complement elementof cardinality : -> Instr [ctor] .

    op nil : -> Instr [ctor] .
    op __ : Instr Instr -> Instr [ctor assoc id: nil] .

    op block_start_end : Qid Instr -> Block [ctor] .
    op nil : -> Block [ctor] .
    op __ : Block Block -> Block [ctor assoc id: nil] .

    sorts BlockMap Configuration .
    op mt : -> BlockMap [ctor] .
    op _|->_ : Qid Block -> BlockMap [ctor] .
    op __ : BlockMap BlockMap -> BlockMap [ctor comm assoc id: mt] .
    eq (L |-> B1) (L |-> B2) = L |-> B1 B2 .

    vars B1 B2 : Block .

    sort Unification .
    op mt : -> Unification [ctor] .
    op __ : Unification Unification -> Unification [ctor comm assoc id: mt] .

    sort UnificationItem .
    subsort UnificationItem < Unification .
    op constraint : Qid Val Val -> UnificationItem [ctor] .
    op _=_ : Val Val -> UnificationItem [ctor comm] .
    op _/=_ : Val Val -> UnificationItem [ctor comm] .
    op failure : -> UnificationItem [ctor] .

    var Unif : Unification .
    var UIt : UnificationItem .

    sort State .
    op nil : -> State [ctor] .
    op state : Instr Unification Stack -> State [ctor] .
    op runGenerator : Qid Generator State -> State [ctor] .
    op runUnif : Instr Unification Stack -> State [ctor] .
    op __ : State State -> State [ctor assoc id: nil] .

    var B Bs Bs1 Bs2 : Block .
    var BM1 BM2 Blocks : BlockMap .
    vars L L1 L2 X Y Z : Qid .
    var I I1 I2 Is : Instr .

    var Str Str1 Str2 : String .

    op [_,_,_] : Nat BlockMap State -> Configuration [ctor] .

    op blocks : Block -> Configuration .
    eq blocks(B) = buildConfig(mt, B) .

    op buildConfig : BlockMap Block -> Configuration .
    eq buildConfig(Blocks, nil) = [0, Blocks, state(lbl('main) goto, mt, nil)] .
    eq buildConfig(Blocks, block L start Is end Bs) = buildConfig(Blocks (L |-> block L start Is end), Bs) .

    var S : Stack .

    var V W : Val .

    vars State States : State .

    var Counter : Nat .

    op makeBlockStates : Block Unification Stack -> State .
    eq makeBlockStates(nil, Unif, S) = nil .
    eq makeBlockStates(block L start Is end Bs, Unif, S) =
        state(Is, Unif, S)
        makeBlockStates(Bs, Unif, S) .

    vars Gen NewGen Gens : Generator .
    crl [generateNew]:
        [ Counter, Blocks, runGenerator(X, Gen, state(Is, Unif, S)) States ]
        =>
        [ Counter, Blocks, runUnif(Is, (X = N) Unif, S) States runGenerator(X, NewGen, state(Is, Unif, S)) ]
        if < NewGen ; N > := next(Gen) .

    --- eq runGenerator(X, nil, State) = nil .
    --- eq runGenerator(X, empty, State) = nil .

    crl [generateDone]:
        [ Counter, Blocks, runGenerator(X, Gen, State) States ]
        =>
        [ Counter, Blocks, States ]
        if done(Gen) .

    rl [goto]:
        [ Counter, (L |-> Bs) Blocks , state(goto, Unif, L S) States ]
        =>
        [ Counter, (L |-> Bs) Blocks , States makeBlockStates(Bs, Unif, S) ] .

    rl [branch]:
        [ Counter, (L1 |-> Bs1) (L2 |-> Bs2) Blocks , state(branch, Unif, L1 L2 S) States ]
        =>
        [ Counter, (L1 |-> Bs1) (L2 |-> Bs2) Blocks , States makeBlockStates(Bs1 Bs2, Unif, S) ] .

    vars N M : Int .
    var Deps : VarList .

    --- Push values
    eq state(int(N) Is, Unif, S) = state(Is, Unif, N S) .
    eq state(str(Str) Is, Unif, S) = state(Is, Unif, s(Str) S) .
    eq state(v(X) Is, Unif, S) = state(Is, Unif, X S) .
    eq state(lbl(L) Is, Unif, S) = state(Is, Unif, L S) .
    eq state(functor(X, N) Is, Unif, S) = state(Is, Unif, func(X, take(N, S)) drop(N, S)) .
    eq state(emptyset Is, Unif, S) = state(Is, Unif, ({} C= universal) S) .

    --- Set operations
    eq state(singleton Is, Unif, V S) = state(Is, Unif, ({V} C= universeOf(V)) S) .
    eq state(union Is, Unif, V W S) = state(Is, Unif, (V U W) S) .
    eq state(subset Is, Unif, V W S) = state(Is, Unif, (V C= W) S) .
    eq state(intersection Is, Unif, V W S) = state(Is, Unif, (V intersect W) S) .
    eq state(complement Is, Unif, V S) = state(Is, Unif, complement(V) S) .
    eq state(elementof Is, Unif, V W S) = state(Is, constraint('in, V, W) Unif, S) .
    eq state(cardinality Is, Unif, V S) = state(Is, Unif, | V | S ) .

    --- Stack operations
    eq state(swap Is, Unif, V W S) = state(Is, Unif, W V S) .
    eq state(pop Is, Unif, V S) = state(Is, Unif, S) .
    eq state(dup Is, Unif, V S) = state(Is, Unif, V V S) .
    eq state(rot Is, Unif, V W T S) = state(Is, Unif, W T V S) .
    eq state(nth(N) Is, Unif, S) = state(Is, Unif, moveNth(S, N)) .

    --- Value testing
    eq state(isvar Is, Unif, V S) = if isVar(V, Unif) then state(Is, Unif, V S) else nil fi .
    eq state(nonvar Is, Unif, V S) = if not isVar(V, Unif) then state(Is, Unif, V S) else nil fi .

    --- Unification
    eq state(unif Is, Unif, V W S) = runUnif(Is, (V = W) Unif, S) .
    eq state(dif Is, Unif, V W S) = runUnif(Is, (V /= W) Unif, S) .

    --- Control Flow
    eq state(fail Is, Unif, S) = nil .
    eq state(call Is, Unif, func(F, Args) S) = state(lbl(F) goto Is, Unif, Args S) .

    --- Choose
    eq state(choose Is, Unif, X S) = state(chooseDeps(dependencies(X, Unif)) Is, Unif, S) .

    eq runUnif(Is, Unif, S) = doUnif(performUnif(Unif), Is, S) .

    --- Arithmetic
    eq state(add Is, Unif, V W S) = state(Is, Unif, func('add, V W) S) .
    eq state(sub Is, Unif, V W S) = state(Is, Unif, func('sub, V W) S) .
    eq state(mul Is, Unif, V W S) = state(Is, Unif, func('mul, V W) S) .
    eq state(mod Is, Unif, V W S) = state(Is, Unif, func('mod, V W) S) .

    --- Arithmetic tests
    eq state(lt Is, Unif, V W S) = runUnif(Is, constraint('lt, V, W) Unif, S) .
    eq state(lte Is, Unif, V W S) = runUnif(Is, constraint('lte, V, W) Unif, S) .

    rl [fresh]:
        [ Counter, Blocks, state(fresh Is, Unif, S) States ]
        =>
        [ Counter + 1, Blocks, state(Is, Unif, qid(string(Counter, 10)) S) States ] .

    eq chooseDeps(none) = nil .

    rl [chooseDepsGen]:
        [ Counter, Blocks, state(chooseDeps(X : Vars) Is, Unif, S) States ]
        =>
        [ Counter, Blocks, runGenerator(X, makeGenerator(unifToDom(X, Unif)), state(chooseDeps(Vars) Is, Unif, S)) States ] .

    sort VarList .
    subsort Qid < VarList .
    vars Vars Vars1 Vars2 Vars3 : VarList .

    op none : -> VarList [ctor] .
    op _:_ : VarList VarList -> VarList [ctor assoc id: none] .
    eq Vars1 : X : Vars2 : X : Vars3 = Vars1 : X : Vars2 : Vars3 .

    op insertChoose : VarList -> Instr .
    eq insertChoose(none) = nil .
    eq insertChoose(X) = v(X) choose .
    eq insertChoose(X : Vars) = v(X) choose insertChoose(Vars) .

    op dependencies : Stack Unification -> VarList .
    eq dependencies(Vs, Unif) = findDeps(none, Vs, Unif) .

    var Op : Qid .
    var Xs Ys : SimpleSet .

    op findDeps : VarList Stack Unification -> VarList .
    eq findDeps(Vars, nil, Unif) = Vars .

    eq findDeps(Vars, N Vs, Unif) = findDeps(Vars, Vs, Unif) .
    eq findDeps(Vars, s(Str) Vs, Unif) = findDeps(Vars, Vs, Unif) .
    eq findDeps(Vars, func(F, Args) Vs, Unif) = findDeps(Vars, Vs Args, Unif) .
    eq findDeps(Vars, (Xs C= Ys) Vs, Unif) = findDeps(Vars, Vs asVals(Xs) asVals(Ys), Unif) .

    eq findDeps(Vars, X Vs, (X = T) Unif) = findDeps(Vars, X Vs T, Unif) .
    eq findDeps(Vars, X Vs, (X /= T) Unif) = findDeps(Vars, X Vs T, Unif) .
    eq findDeps(Vars, X Vs, constraint(Op, X, T) Unif) = findDeps(Vars, X Vs T, Unif) .
    eq findDeps(Vars, X Vs, constraint(Op, T, X) Unif) = findDeps(Vars, X Vs T, Unif) .
    eq findDeps(Vars, X Vs, (func(F, Args) = func(G, ArgsF X ArgsG)) Unif) = findDeps(Vars, X Vs Args ArgsF ArgsG, Unif) .
    eq findDeps(Vars, X Vs, (func(F, Args) /= func(G, ArgsF X ArgsG)) Unif) = findDeps(Vars, X Vs Args ArgsF ArgsG, Unif) .
    eq findDeps(Vars, X Vs, constraint(Op, func(F, Args), func(G, ArgsF X ArgsG)) Unif) = findDeps(Vars, X Vs Args ArgsF ArgsG, Unif) .
    eq findDeps(Vars, X Vs, constraint(Op, func(F, ArgsF X ArgsG), func(G, Args)) Unif) = findDeps(Vars, X Vs Args ArgsF ArgsG, Unif) .

    eq findDeps(Vars, X Vs, Unif) = findDeps(X : Vars, Vs, Unif) [owise] .

    op isVar : Val Unification -> Bool .
    eq isVar(N, Unif) = false .
    eq isVar(func(F, Args), Unif) = false .
    eq isVar(s(Str), Unif) = false .
    eq isVar(X, (X = V) Unif) = isVar(V, Unif) .
    eq isVar(X, Unif) = true [owise] .

    vars F G : Qid .
    vars Vs Args : Stack .

    op varsOf : Unification -> VarList .
    op varsOf : Val -> VarList .
    op varsOf : Stack -> VarList .
    eq varsOf(X) = X .
    eq varsOf(N) = none .
    eq varsOf(s(Str)) = none .
    eq varsOf(func(F, Args)) = varsOf(Args) .
    eq varsOf(nil) = none .
    eq varsOf(V W Vs) = varsOf(V) : varsOf(W Vs) .
    eq varsOf(mt) = none .
    eq varsOf((V = W) Unif) = varsOf(V) : varsOf(W) : varsOf(Unif) .
    eq varsOf((V /= W) Unif) = varsOf(V) : varsOf(W) : varsOf(Unif) .
    eq varsOf(constraint(Op, V, W) Unif) = varsOf(V) : varsOf(W) : varsOf(Unif) .

    op inVars : Qid Unification -> Bool .
    op inVars : Qid Stack -> Bool .
    eq inVars(Y, X) = Y == X .
    eq inVars(Y, N) = false .
    eq inVars(Y, s(Str)) = false .
    eq inVars(Y, func(F, Args)) = inVars(Y, Args) .
    eq inVars(Y, nil) = false .
    eq inVars(Y, V W Vs) = inVars(Y, V) or inVars(Y, W Vs) .
    eq inVars(Y, mt) = false .
    eq inVars(Y, (V = W) Unif) = inVars(Y, V) or inVars(Y, W) or inVars(Y, Unif) .
    eq inVars(Y, (V /= W) Unif) = inVars(Y, V) or inVars(Y, W) or inVars(Y, Unif) .
    eq inVars(Y, constraint(Op, V, W) Unif) = inVars(Y, V) or inVars(Y, W) or inVars(Y, Unif) .

    var Fun : Func .
    vars ArgsG ArgsF Ws : Stack .
    var T : Val .

    eq (V = V) = mt .
    eq s(Str1) = s(Str2) = if Str1 == Str2 then mt else failure fi .
    eq s(Str1) /= s(Str2) = if Str1 =/= Str2 then mt else failure fi .
    eq N = s(Str) = failure .
    eq N /= s(Str) = mt .
    eq N = M = if N == M then mt else failure fi .
    eq N /= M = if N =/= M then mt else failure fi .
    eq constraint('lt, N, M) = if N < M then mt else failure fi .
    eq constraint('lte, N, M) = if N <= M  then mt else failure fi .
    eq failure UIt Unif = failure .

    eq (N = func('add, V M)) = (V = sub(N, M)) .
    eq (N = func('add, M V)) = (V = sub(N, M)) .
    eq (N = func('sub, V M)) = (V = N + M) .
    eq (N = func('sub, M V)) = (V = N + M) .

    ceq constraint(Op, N, func('add, V M)) = constraint(Op, sub(N, M), V) if orderConstraint(Op) .
    ceq constraint(Op, N, func('add, M V)) = constraint(Op, sub(N, M), V) if orderConstraint(Op) .
    ceq constraint(Op, N, func('sub, V M)) = constraint(Op, N + M, V) if orderConstraint(Op) .
    ceq constraint(Op, N, func('sub, M V)) = constraint(Op, N + M, V) if orderConstraint(Op) .
    ceq constraint(Op, func('add, V M), N) = constraint(Op, V, sub(N, M)) if orderConstraint(Op) .
    ceq constraint(Op, func('add, M V), N) = constraint(Op, V, sub(N, M)) if orderConstraint(Op) .
    ceq constraint(Op, func('sub, V M), N) = constraint(Op, V, N + M) if orderConstraint(Op) .
    ceq constraint(Op, func('sub, M V), N) = constraint(Op, V, N + M) if orderConstraint(Op) .

    eq func('add, 0 V) = V .
    eq func('add, V 0) = V .
    eq func('add, N M) = N + M .
    eq func('sub, N M) = sub(N, M) .
    eq func('sub, V 0) = V .
    eq func('sub, V V) = 0 .
    eq func('add, V V) = func('mul, 2 V) .
    eq func('mod, N M) = N rem M .
    eq func('mod, V V) = 0 .
    eq func('mod, 0 V) = 0 .
    eq func('mul, N M) = N * M .
    eq func('mul, 0 W) = 0 .
    eq func('mul, W 0) = 0 .
    eq func('mul, 1 W) = W .
    eq func('mul, W 1) = W .

    vars Q R : Int .
    ceq (N = func('mul, M V)) = if R == 0 then (V = Q) else failure fi
        if R := N rem M /\
           Q := N quo M .
    ceq (N = func('mul, V M)) = if R == 0 then (V = Q) else failure fi
        if R := N rem M /\
           Q := N quo M .

    ceq (constraint(Op, N, func('mul, M V))) = constraint(Op, Q, V)
        if orderConstraint(Op) /\
           R := N rem M /\
           Q := N quo M /\
           R == 0 .
    ceq (constraint(Op, N, func('mul, V M))) = constraint(Op, Q, V)
        if orderConstraint(Op) /\
           R := N rem M /\
           Q := N quo M /\
           R == 0 .
    ceq (constraint(Op, func('mul, M V), N)) = constraint(Op, V, Q)
        if orderConstraint(Op) /\
           R := N rem M /\
           Q := N quo M /\
           R == 0 .
    ceq (constraint(Op, func('mul, V M), N)) = constraint(Op, V, Q)
        if orderConstraint(Op) /\
           R := N rem M /\
           Q := N quo M /\
           R == 0 .

    --- We always have V^2 >= 0
    eq constraint('lte, 0, func('mul, V V)) = mt .
    eq constraint('lt, func('mul, V V), 0) = failure .
    ceq (N = func('mul, V V)) = failure if N < 0 .

    ceq (func(Op, V W) = func(Op, V T)) = (W = T) if cancellable(Op) .
    ceq (func(Op, W V) = func(Op, T V)) = (W = T) if cancellable(Op) .
    ceq (func(Op, V W) = func(Op, T V)) = (W = T) if cancellable(Op) and commutes(Op) .

    var VSet : Subset .

    ceq constraint('in, V, VSet) = mt if V in VSet .
    ceq constraint('in, V, VSet) = failure if not V in VSet .

    op orderConstraint : Qid -> Bool .
    eq orderConstraint('lt) = true .
    eq orderConstraint('lte) = true .
    eq orderConstraint(X) = false [owise] .

    op isSpecial : Qid -> Bool .
    eq isSpecial('add) = true .
    eq isSpecial('sub) = true .
    eq isSpecial('mul) = true .
    eq isSpecial('mod) = true .
    eq isSpecial('set) = true .
    eq isSpecial(X) = false [owise] .

    op cancellable : Qid -> Bool .
    eq cancellable('add) = true .
    eq cancellable('sub) = true .
    eq cancellable('mul) = true .
    eq cancellable(X) = false [owise] .

    op commutes : Qid -> Bool .
    eq commutes('add) = true .
    eq commutes('mul) = true .
    eq commutes(X) = false [owise] .

    op unifPossible : Unification -> Bool .
    eq unifPossible(mt) = true .
    eq unifPossible(failure Unif) = false .
    eq unifPossible((V /= W) Unif) = not unifPossible(performUnif((V = W) Unif)) .
    eq unifPossible((X = T) Unif) = not inVars(X, T) and unifPossible(Unif) .
    eq unifPossible((func(F, ArgsF) = func(G, ArgsG)) Unif) = isSpecial(F) and isSpecial(G) and unifPossible(Unif) .
    eq unifPossible(UIt Unif) = unifPossible(Unif) [owise] .

    op makeEqualities : Stack Stack -> Unification .
    eq makeEqualities(nil, nil) = mt .
    eq makeEqualities(V Vs, W Ws) = (V = W) makeEqualities(Vs, Ws) .

    vars Xp Yp : PreSet .

    op substitute : Qid Val Unification -> Unification .
    op substitute : Qid Val Stack -> Stack .
    op substitute : Qid Val Val -> Val .
    eq substitute(X, W, mt) = mt .
    eq substitute(X, W, V = T) = (substitute(X, W, V) = substitute(X, W, T)) .
    eq substitute(X, W, constraint(Op, V, T)) = constraint(Op, substitute(X, W, V), substitute(X, W, T)) .
    eq substitute(X, W, V /= T) = (substitute(X, W, V) /= substitute(X, W, T)) .
    eq substitute(X, W, UIt Unif) = substitute(X, W, UIt) substitute(X, W, Unif) .
    eq substitute(X, W, Y) = if X == Y then W else Y fi .
    eq substitute(X, W, N) = N .
    eq substitute(X, W, s(Str)) = s(Str) .
    eq substitute(X, W, func(F, Args)) = func(F, substitute(X, W, Args)) .
    eq substitute(X, W, (Xs C= Ys)) = setSubstitute(X, W, Xs) C= setSubstitute(X, W, Ys) .
    eq substitute(X, W, nil) = nil .
    eq substitute(X, W, V T Vs) = substitute(X, W, V) substitute(X, W, T Vs) .

    op setSubstitute : Qid Val SimpleSet -> SimpleSet .
    eq setSubstitute(X, W, {}) = {} .
    eq setSubstitute(X, W, {Xp}) = {presubstitute(X,W,Xp)} .
    eq setSubstitute(X, W, Xs U Ys) = setSubstitute(X, W, Xs) U setSubstitute(X, W, Ys) .
    eq setSubstitute(X, W, ints) = ints .
    eq setSubstitute(X, W, universal) = universal .

    op presubstitute : Qid Val PreSet -> PreSet .
    eq presubstitute(X, W, empty) = empty .
    eq presubstitute(X, W, V) = substitute(X, W, V) .
    eq presubstitute(X, W, V ; T ; Xp) = substitute(X, W, V) ; presubstitute(X, W, T ; Xp) .

    op performUnif : Unification -> Unification .
    ceq performUnif((X = T) Unif) = performUnif((X = T) substitute(X, T, Unif))
        if not inVars(X, T) and notVar(T) and inVars(X, Unif) .
    ceq performUnif((X = Y) Unif) = performUnif((X = Y) substitute(X, Y, Unif))
        if X =/= Y and inVars(X, Unif) and inVars(Y, Unif) .

    --- We can only do this for non-builtin operations (because X + Y = A + B doesn't mean X = A and Y = B)
    ceq performUnif((func(F, ArgsF) = func(F, ArgsG)) Unif) = performUnif(makeEqualities(ArgsF, ArgsG) Unif)
        if not isSpecial(F) .

    var Vals : Stack .
    --- If all the constraints we have guarantee a single value for some variable, just unify the variable with it's single value
    ceq performUnif(Unif) = performUnif((X = V) Unif)
        if (Vs : X : Ws) := varsOf(Unif) /\
           not (inEquation(X, Unif)) /\
           computed(V) := domToVals(unifToDom(X, Unif)) .

    ceq performUnif(Unif) = failure
        if (Vs : X : Ws) := varsOf(Unif) /\
           computed(nil) := domToVals(unifToDom(X, Unif)) .

    eq performUnif(Unif) = Unif [owise] .

    var NewUnif : Unification .

    op inEquation : Qid Unification -> Bool .
    eq inEquation(X, (X = V) Unif) = true .
    eq inEquation(X, Unif) = false [owise] .

    op unifToDom : Qid Unification -> Subset .
    eq unifToDom(X, mt) = universalsub .
    eq unifToDom(X, constraint('lt, X, M) Unif) = (range(negInf, sub(M, 1)) C= ints) intersect unifToDom(X, Unif) .
    eq unifToDom(X, constraint('lte, X, M) Unif) = (range(negInf, M) C= ints) intersect unifToDom(X, Unif) .
    eq unifToDom(X, constraint('lt, N, X) Unif) = (range(N + 1, posInf) C= ints) intersect unifToDom(X, Unif) .
    eq unifToDom(X, constraint('lte, N, X) Unif) = (range(N, posInf) C= ints) intersect unifToDom(X, Unif) .
    eq unifToDom(X, constraint('in, X, Xs C= Ys) Unif) = (Xs C= Ys) intersect unifToDom(X, Unif) .
    eq unifToDom(X, (X = N) Unif) = range(N, N) C= ints .
    eq unifToDom(X, (X /= N) Unif) = ((range(negInf, sub(N, 1) U range(N + 1, posInf)) C= ints) intersect unifToDom(X, Unif)) .
    eq unifToDom(X, UIt Unif) = unifToDom(X, Unif) [owise] .

    vars Dom1 Dom2 Dom : Subset .

    op doUnif : Unification Instr Stack -> State .
    eq doUnif(NewUnif, Is, S) =
        if unifPossible(NewUnif) then
            state(Is, NewUnif, S)
        else nil fi .

    --- Stop on the first solution found .
    subsort State < Configuration .
    op <_;_> : State Configuration -> Configuration [ctor frozen] .
    rl [stop]:
        [ Counter, Blocks, state(nil, Unif, S) States ]
        =>
        < state(nil, Unif, S) ; [ Counter, Blocks, States ] > .

    op reachable : Qid Stack Unification -> Bool .
    eq reachable(X, nil, Unif) = false .

    eq reachable(X, N Vs, Unif) = reachable(X, Vs, Unif) .
    eq reachable(X, s(Str) Vs, Unif) = reachable(X, Vs, Unif) .
    eq reachable(X, func(F, Args) Vs, Unif) = reachable(X, Args Vs, Unif) .

    eq reachable(X, X Vs, Unif) = true .

    eq reachable(X, Y Vs, (Y = T) Unif) = reachable(X, Y T Vs, Unif) .
    eq reachable(X, Y Vs, (Y /= T) Unif) = reachable(X, Y T Vs, Unif) .
    eq reachable(X, Y Vs, constraint(Op, Y, T) Unif) = reachable(X, Y T Vs T, Unif) .
    eq reachable(X, Y Vs, constraint(Op, T, Y) Unif) = reachable(X, Y Vs T, Unif) .
    eq reachable(X, Y Vs, (T = func(G, ArgsF Y ArgsG)) Unif) = reachable(X, Y T ArgsF ArgsG Vs, Unif) .
    eq reachable(X, Y Vs, (T /= func(G, ArgsF Y ArgsG)) Unif) = reachable(X, Y T ArgsF ArgsG Vs, Unif) .
    eq reachable(X, Y Vs, constraint(Op, T, func(G, ArgsF Y ArgsG)) Unif) = reachable(X, Y T ArgsF ArgsG Vs, Unif) .
    eq reachable(X, Y Vs, constraint(Op, func(F, ArgsF Y ArgsG), T) Unif) = reachable(X, Y T ArgsF ArgsG Vs, Unif) .

    eq reachable(X, Y Vs, Unif) = reachable(X, Vs, Unif) [owise] .

    crl [garbageCollectMid]:
        [ Counter, Blocks, state(Is, UIt Unif, S) States ]
        =>
        [ Counter, Blocks, state(Is, Unif, S) States ]
        if Vars1 : X : Vars2 := varsOf(UIt) /\
           not reachable(X, S, UIt Unif) .

    var C : Configuration .
    ceq < state(Is, UIt Unif, S) ; C > = < state(Is, Unif, S) ; C >
        if Vars1 : X : Vars2 := varsOf(UIt) /\
           not reachable(X, S, UIt Unif) .
endm

