load domain
load sets

mod GENERATOR is
    protecting DOMAIN .
    protecting LOGIC-STACK .

    sorts Generator GeneratorRes .

    op <_;_> : Generator Stack -> GeneratorRes [ctor] .

    subsort Domain < Generator .
    op nil : -> Generator .
    op __ : Generator Generator -> Generator [ctor assoc] .

    eq nil Gens = Gens .
    eq Gens nil = Gens .

    vars Dom Dom1 Dom2 : Domain .
    vars Low High : ExInt .
    vars N M : Int .

    op makeGenerator : Domain -> Generator .
    eq makeGenerator(empty) = nil .
    eq makeGenerator(universal) = range(negInf, 0) range(1, posInf) .
    eq makeGenerator(range(Low, High)) = range(Low, High) .
    eq makeGenerator(range(Low, High) U Dom) = range(Low, High) makeGenerator(Dom) .

    vars Gen NewGen Gens : Generator .

    eq empty Gen = Gen .
    eq Gen empty = Gen .

    op done : Generator -> Bool .
    eq done(Gen) = Gen == nil or Gen == empty .

    op next : Generator -> GeneratorRes .
    eq next(range(negInf, N)) = < range(negInf, sub(N, 1)) ; N > .
    eq next(range(N, High)) = < range(N + 1, High) ; N > .
    ceq next(universal) = < Gen range(1, posInf) ; N >
        if < Gen ; N > := next(range(negInf, 0)) .
    ceq next(Gen Gens) = < Gens NewGen ; N >
        if < NewGen ; N > := next(Gen) .

    var FinalGen : Generator .
    vars Vs Ws : Stack .

    var C : Nat .

    op genMany : Generator Nat -> GeneratorRes .
    eq genMany(Gen, 0) = < Gen ; nil > .
    ceq genMany(Gen, s(C)) = < FinalGen ; M Vs >
        if < NewGen ; M > := next(Gen) /\
           < FinalGen ; Vs > := genMany(NewGen, C) .

    --- Will yield computed(Vs) if the domain is finite
    op domToVals : Domain -> Computed .
    eq domToVals(empty) = computed(nil) .
    eq domToVals(range(N, M)) = computed(buildRange(N, M)) .
    ceq domToVals(Dom1 U Dom2) = computed(Vs Ws)
        if computed(Vs) := domToVals(Dom1) /\
           computed(Ws) := domToVals(Dom2) .
    eq domToVals(Dom) = insufficient [owise] .
endm

