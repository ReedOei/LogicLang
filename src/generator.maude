load sets

mod GENERATOR is
    protecting SETS .

    sorts Generator GeneratorRes .

    op <_;_> : Generator Stack -> GeneratorRes [ctor] .

    --- subsort Subset < Generator .
    op nogen : -> Generator .
    op __ : Generator Generator -> Generator [ctor assoc] .

    eq nogen Gen = Gen .
    eq Gen nogen = Gen .

    op [_.._] : ExInt ExInt -> Generator [ctor] .
    ceq [ Low .. High ] = nogen if not isLte(Low + 1, High) .

    op finset : PreSet -> Generator [ctor] .
    eq finset(empty) = nogen .

    vars Dom Dom1 Dom2 : Subset .
    vars Low High : ExInt .
    vars N M : Int .

    vars As Bs : SimpleSet .
    vars Ap Bp : PreSet .

    op makeGenerator : Subset -> Generator .
    eq makeGenerator({} C= Bs) = nogen .
    eq makeGenerator(ints C= As) = [negInf .. 0] [1 .. posInf] .
    eq makeGenerator(range(Low, High) C= As) = [Low .. High] .
    eq makeGenerator({Ap} C= Bs) = finset(Ap) .
    eq makeGenerator(As U Bs) = makeGenerator(As) makeGenerator(Bs) .

    --- TODO: What to do in this case?
    --- eq makeGenerator(universalsub) = range(negInf, 0) range(1, posInf) .

    vars Gen Gen1 Gen2 NewGen Gens : Generator .

    op done : Generator -> Bool .
    eq done(nogen) = true .
    eq done(Gen) = false [owise] .

    vars V W : Val .

    op next : Generator -> GeneratorRes .
    eq next([negInf .. N]) = < [negInf .. sub(N, 1)] ; N > .
    eq next([N .. High]) = < [N + 1 .. High] ; N > .
    eq next(finset(V ; Ap)) = < finset(Ap) ; V > .
    ceq next(Gen Gens) = < Gens NewGen ; N >
        if < NewGen ; N > := next(Gen) .

    var FinalGen : Generator .
    vars Vs Ws : Stack .

    var C : Nat .

    op genMany : Generator Nat -> GeneratorRes .
    eq genMany(Gen, 0) = < Gen ; nil > .
    ceq genMany(Gen, s(C)) = < FinalGen ; M Vs >
        if < NewGen ; M > := next(Gen) /\
           < FinalGen ; Vs > := genMany(NewGen, C) .

    --- Will yield computed(Vs) if the domain is finite
    op domToVals : Subset -> Computed .
    eq domToVals(empty) = computed(nil) .
    eq domToVals({Ap}) = computed(asVals(Ap)) .
    eq domToVals(range(N, M)) = computed(buildRange(N, M)) .
    ceq domToVals(Dom1 U Dom2) = computed(Vs Ws)
        if computed(Vs) := domToVals(Dom1) /\
           computed(Ws) := domToVals(Dom2) .
    eq domToVals(Dom) = insufficient [owise] .
endm

