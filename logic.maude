mod LOGIC is
    --- protecting NAT .
    protecting INT .
    protecting QID .
    protecting STRING .
    protecting CONVERSION .

    sorts Instr Block Func .

    ops call branch goto : -> Instr [ctor] .
    ops fresh nonvar isvar unif dif : -> Instr [ctor] .
    ops swap pop rot dup : -> Instr [ctor] .
    ops lt lte add sub : -> Instr [ctor] .
    op lookup : -> Instr [ctor] .
    op v : Qid -> Instr [ctor] .
    op lbl : Qid -> Instr [ctor] .
    op int : Int -> Instr [ctor] .
    op functor : Qid Nat -> Instr [ctor] .

    op func : Qid Stack -> Func [ctor] .

    op nil : -> Instr [ctor] .
    op __ : Instr Instr -> Instr [ctor assoc id: nil] .

    op block_start_end : Qid Instr -> Block [ctor] .
    op nil : -> Block [ctor] .
    op __ : Block Block -> Block [ctor assoc id: nil] .

    sorts BlockMap Configuration .
    op mt : -> BlockMap [ctor] .
    op _|->_ : Qid Instr -> BlockMap [ctor] .
    op __ : BlockMap BlockMap -> BlockMap [ctor comm assoc id: mt] .
    op [_,_,_] : Nat BlockMap State -> Configuration [ctor] .

    sorts Stack Unification Val .
    subsort Int < Val .
    subsort Qid < Val .
    subsort Func < Val .
    subsort Val < Stack .
    op nil : -> Stack [ctor] .
    op __ : Stack Stack -> Stack [ctor assoc id: nil] .

    op mt : -> Unification [ctor] .
    op __ : Unification Unification -> Unification [ctor comm assoc id: mt] .
    op _=_ : Val Val -> Unification [ctor comm] .
    op _/=_ : Val Val -> Unification [ctor comm] .

    sort State .
    op nil : -> State [ctor] .
    op state : Instr Unification Stack -> State [ctor] .
    op __ : State State -> State [ctor assoc id: nil] .

    var B Bs : Block .
    var BM1 BM2 Blocks : BlockMap .
    vars L L1 L2 X Y : Qid .
    var I I1 I2 Is : Instr .

    op program : Block -> Configuration .
    eq program(B) = buildConfig(mt, B) .

    op buildConfig : BlockMap Block -> Configuration .
    eq buildConfig(Blocks, nil) = [0, Blocks, state(lbl('main) goto, mt, nil)] .
    eq buildConfig(Blocks, block L start Is end Bs) = buildConfig(Blocks (L |-> Is), Bs) .

    var Unif : Unification .
    var S : Stack .

    var V W : Val .

    var States : State .

    var Counter : Nat .

    rl [goto]:
        [ Counter, (L |-> Is) Blocks , state(goto, Unif, L S) States ]
        =>
        [ Counter, (L |-> Is) Blocks , States state(Is, Unif, S) ] .

    rl [branch]:
        [ Counter, (L1 |-> I1) (L2 |-> I2) Blocks , state(branch, Unif, L1 L2 S) States ]
        =>
        [ Counter, (L1 |-> I1) (L2 |-> I2) Blocks , States state(I1, Unif, S) state(I2, Unif, S) ] .

    rl [var]:
        [ Counter, Blocks, state(v(V) Is, Unif, S) States ]
        =>
        [ Counter, Blocks, States state(Is, Unif, V S) ] .

    rl [lbl]:
        [ Counter, Blocks , state(lbl(L) Is, Unif, S) States ]
        =>
        [ Counter, Blocks , States state(Is, Unif, L S) ] .

    rl [dup]:
        [ Counter, Blocks, state(dup Is, Unif, V S) States ]
        =>
        [ Counter, Blocks, States state(Is, Unif, V V S) ] .

    rl [rot]:
        [ Counter, Blocks, state(rot Is, Unif, V W T S) States ]
        =>
        [ Counter, Blocks, States state(Is, Unif, W T V S) ] .

    rl [pop]:
        [ Counter, Blocks, state(pop Is, Unif, V S) States ]
        =>
        [ Counter, Blocks, States state(Is, Unif, S) ] .

    rl [swap]:
        [ Counter, Blocks, state(swap Is, Unif, V W S) States ]
        =>
        [ Counter, Blocks, States state(Is, Unif, W V S) ] .

    vars N M : Int .
    rl [int]:
        [ Counter, Blocks, state(int(N) Is, Unif, S) States ]
        =>
        [ Counter, Blocks, States state(Is, Unif, N S) ] .

    rl [add]:
        [ Counter, Blocks, state(add Is, Unif, N M S) States ]
        =>
        [ Counter, Blocks, States state(Is, Unif, (N + M) S) ] .

    --- TODO: ADD A CONSTRAINT ENVIRONMENT TO EACH STATE (PROBBALY PART OF THE UNIFICATION)
    rl [lookupInt]:
        [ Counter, Blocks, state(lookup Is, Unif, N S) States ]
        =>
        [ Counter, Blocks, States state(Is, Unif, N S) ] .

    rl [lookupVarIsInt]:
        [ Counter, Blocks, state(lookup Is, (X = N) Unif, X S) States ]
        =>
        [ Counter, Blocks, States state(Is, (X = N) Unif, N S) ] .

    rl [lookupVarIsFunc]:
        [ Counter, Blocks, state(lookup Is, (X = func(F, Args)) Unif, X S) States ]
        =>
        [ Counter, Blocks, States state(Is, (X = func(F, Args)) Unif, func(F, Args) S) ] .

    rl [lookupIsVar]:
        [ Counter, Blocks, state(lookup Is, (X = Y) Unif, X S) States ]
        =>
        [ Counter, Blocks, States ] .

    rl [lookupFunc]:
        [ Counter, Blocks, state(lookup Is, Unif, func(F, Args) S) States ]
        =>
        [ Counter, Blocks, States state(Is, Unif, S func(F, Args)) ] .

    op sub : Int Int -> Int .
    --- For some reason it doesn't like N - M (multiple parses)
    eq sub(N, M) = (N + - M) .
    rl [sub]:
        [ Counter, Blocks, state(sub Is, Unif, N M S) States ]
        =>
        [ Counter, Blocks, States state(Is, Unif, sub(N, M) S) ] .

    rl [lt]:
        [ Counter, Blocks, state(lt Is, Unif, N M S) States ]
        =>
        [ Counter, Blocks, States if N < M then state(Is, Unif, S) else nil fi ] .

    rl [lte]:
        [ Counter, Blocks, state(lte Is, Unif, N M S) States ]
        =>
        [ Counter, Blocks, States if N <= M then state(Is, Unif, S) else nil fi ] .

    rl [fresh]:
        [ Counter, Blocks, state(fresh Is, Unif, S) States ]
        =>
        [ Counter + 1, Blocks, States state(Is, Unif, qid(string(Counter, 10)) S) ] .

    rl [isvar]:
        [ Counter, Blocks, state(isvar Is, Unif, V S) States ]
        =>
        [ Counter, Blocks, States if not notVar(V) then state(Is, Unif, S) else nil fi ] .

    rl [nonvar]:
        [ Counter, Blocks, state(nonvar Is, Unif, V S) States ]
        =>
        [ Counter, Blocks, States if notVar(V) then state(Is, Unif, S) else nil fi ] .

    rl [call]:
        [ Counter, Blocks, state(call Is, Unif, func(F, Args) S) States ]
        =>
        [ Counter, Blocks, States state(lbl(F) goto Is, Unif, Args S) ] .

    vars F G : Qid .
    vars Vs Args : Stack .

    op varsOf : Unification -> Stack .
    op varsOf : Val -> Val .
    op varsOf : Stack -> Stack .
    eq varsOf(X) = X .
    eq varsOf(N) = nil .
    eq varsOf(func(F, Args)) = varsOf(Args) .
    eq varsOf(nil) = nil .
    eq varsOf(V Vs) = varsOf(V) varsOf(Vs) .
    eq varsOf(mt) = nil .
    eq varsOf((V = W) Unif) = varsOf(V) varsOf(W) varsOf(Unif) .
    eq varsOf((V /= W) Unif) = varsOf(V) varsOf(W) varsOf(Unif) .

    var Vars : Stack .
    op _in_ : Val Stack -> Bool .
    eq V in nil = false .
    eq V in (W Vs) = (V == W) or (V in Vs ) .

    var Fun : Func .
    vars ArgsG ArgsF Ws : Stack .
    var T : Val .

    op unifPossible : Unification -> Bool .
    eq unifPossible(mt) = true .
    eq unifPossible((N = M) Unif) = N == M and unifPossible(Unif) .
    eq unifPossible((X /= T) Unif) = X =/= T and unifPossible(Unif) .
    eq unifPossible((X = T) Unif) = not (X in varsOf(T)) and unifPossible(Unif) .
    --- If this is left over after peforming unification, then we must have failed because we would decompose if F == G.
    eq unifPossible((func(F, ArgsF) = func(G, ArgsG)) Unif) = false .
    eq unifPossible((N = func(F, Args)) Unif) = false .

    op makeEqualities : Stack Stack -> Unification .
    eq makeEqualities(nil, nil) = mt .
    eq makeEqualities(V Vs, W Ws) = (V = W) makeEqualities(Vs, Ws) .

    op notVar : Val -> Bool .
    eq notVar(X) = false .
    eq notVar(Fun) = true .
    eq notVar(N) = true .

    var U : Unification .

    op substitute : Qid Val Unification -> Unification .
    op substitute : Qid Val Stack -> Stack .
    op substitute : Qid Val Val -> Val .
    eq substitute(X, W, mt) = mt .
    eq substitute(X, W, V = T) = (substitute(X, W, V) = substitute(X, W, T)) .
    eq substitute(X, W, V /= T) = (substitute(X, W, V) /= substitute(X, W, T)) .
    ceq substitute(X, W, (V = T) Unif) = substitute(X, W, V = T) substitute(X, W, Unif) if Unif =/= mt .
    ceq substitute(X, W, (V /= T) Unif) = substitute(X, W, V /= T) substitute(X, W, Unif) if Unif =/= mt .
    eq substitute(X, W, Y) = if X == Y then W else Y fi .
    eq substitute(X, W, N) = N .
    eq substitute(X, W, func(F, Args)) = func(F, substitute(X, W, Args)) .
    eq substitute(X, W, nil) = nil .
    eq substitute(X, W, V Vs) = substitute(X, W, V) substitute(X, W, Vs) .

    op performUnif : Unification -> Unification .
    eq performUnif((V = V) Unif) = performUnif(Unif) .
    ceq performUnif((X = T) Unif) = performUnif((X = T) substitute(X, T, Unif))
        if not (X in varsOf(T)) and notVar(T) and X in varsOf(Unif) .
    ceq performUnif((X = Y) Unif) = performUnif((X = Y) substitute(X, Y, Unif))
        if X =/= Y and X in varsOf(Unif) and Y in varsOf(Unif) .
    eq performUnif((func(F, ArgsF) = func(F, ArgsG)) Unif) = performUnif(makeEqualities(ArgsF, ArgsG) Unif) .
    eq performUnif(Unif) = Unif [owise] .

    var NewUnif : Unification .
    crl [unif]:
        [ Counter, Blocks, state(unif Is, Unif, V W S) States ]
        =>
        [ Counter, Blocks, States if unifPossible(NewUnif) then state(Is, NewUnif, S) else nil fi ]
        if NewUnif := performUnif((V = W) Unif) .

    crl [dif]:
        [ Counter, Blocks, state(dif Is, Unif, V W S) States ]
        =>
        [ Counter, Blocks, States if unifPossible(NewUnif) then state(Is, NewUnif, S) else nil fi ]
        if NewUnif := performUnif((V /= W) Unif) .

    var Num : Nat .
    op take : Nat Stack -> Stack .
    eq take(0, S) = nil .
    eq take(Num, nil) = nil .
    eq take(s(Num), V Vs) = V take(Num, Vs) .

    op drop : Nat Stack -> Stack .
    eq drop(0, S) = S .
    eq drop(Num, nil) = nil .
    eq drop(s(Num), V Vs) = drop(Num, Vs) .

    rl [functor]:
        [ Counter, Blocks, state(functor(X, N) Is, Unif, S) States ]
        =>
        [ Counter, Blocks, States state(Is, Unif, func(X, take(N, S)) drop(N, S)) ] .

    --- Stop on the first solution found .
    subsort State < Configuration .
    rl [stop]:
        [ Counter, Blocks, state(nil, Unif, S) States ]
        =>
        state(nil, Unif, S) States .

    op reachable : Qid Unification Stack -> Bool .
    ceq reachable(X, Unif, Vs Y Ws) = true if reachableFrom(X, Y, Unif) .
    ceq reachable(X, Unif, Vs func(F, Args) Ws) = true
        if reachable(X, Unif, Args) .
    eq reachable(X, Unif, S) = false [owise] .

    op reachableFrom : Qid Qid Unification -> Bool .
    eq reachableFrom(X, Y, (X = Y) Unif) = true .
    eq reachableFrom(X, X, Unif) = true .
    eq reachableFrom(X, Y, (Y = func(F, Args)) Unif) = reachable(X, Unif, Args) .
    eq reachableFrom(X, Y, Unif) = false [owise] .

    crl [garbageCollect]:
        state(Is, (X = V) Unif, S)
        =>
        state(Is, Unif, S)
        if not reachable(X, Unif, S) .
endm

--- set trace on .

--- rew program(
--- block 'main start
---     v('X)
---     lbl('X2)
---     lbl('X1)
---     branch
--- end

--- block 'X1 start
---     dup
---     int(1)
---     unif

---     lbl('Gt0)
---     lbl('Lt0)
---     branch
--- end

--- block 'X2 start
---     dup
---     int(0)
---     unif

---     lbl('Gt0)
---     lbl('Lt0)
---     branch
--- end

--- block 'Gt0 start
---     int(3)
---     unif
--- end

--- block 'Lt0 start
---     int(0)
---     unif
--- end
--- ) .

--- rew program(
--- block 'main start
---     functor('empty, 0)
---     int(1)
---     functor('cons, 2)
---     v('X)
---     unif

---     functor('empty, 0)
---     v('Y)
---     unif

---     v('X)
---     v('Y)
---     unif
--- end) .

--- set trace on .
--- set trace eq off .
rew program(
block 'mainbetween start
    v('X)
    lbl('difend)
    int(1)
    int(0)
    v('X)
    lbl('between)
    goto
end

block 'difend start
    v('X)
    lookup
    int(4)
    lt
end

block 'main start
    v('X)
    v('Total)
    lbl('mainafterrange)
    int(10)
    int(0)
    v('X)
    lbl('range)
    goto
end

block 'mainafterrange start
    lbl('end)
    v('X)
    v('Total)
    lbl('sum)
    goto
end

block 'mainlength start
    v('L)
    v('Length)
    lbl('mainafter)
    v('L)
    int(12)
    functor('length, 2)
    call
end

block 'mainafter start
    lbl('end)
    v('L)
    v('Length)
    functor('length, 2)
    call
end

block 'end start
    nil
end

block 'length start
    lbl('lengthempty)
    lbl('lengthcons)
    branch
end

block 'lengthempty start
    int(0)
    unif
    functor('empty, 0)
    unif
    goto
end

block 'lengthcons start
    lbl('lengthconsvar)
    lbl('lengthconsground)
    branch
end

block 'lengthconsvar start
    --- L Xs
    dup
    isvar
    swap
    --- Xs L
    fresh
    --- T Xs L
    dup
    rot
    fresh
    functor('cons, 2)
    --- cons(H, T) Xs T L
    unif
    --- T L
    fresh
    --- TailLen T L
    dup
    --- TailLen TailLen T L
    rot
    --- TailLen T TailLen L
    lbl('lengthconsvarend)
    rot
    --- TailLen T 'lengthconsvarend TailLen L
    lbl('length)
    goto
end

block 'lengthconsvarend start
    lookup
    int(1)
    add
    unif
    goto
end

block 'lengthconsground start
    dup
    nonvar
    dup
    int(0)
    lt
    int(1)
    swap
    sub

    swap
    fresh
    dup
    rot
    fresh
    functor('cons, 2)
    unif

    swap
    lbl('length)
    goto
end

block 'between start
    --- X Low High
    lbl('betweenvar)
    lbl('betweennonvar)
    branch
end

block 'betweenvar start
    --- X Low High
    dup
    isvar
    lbl('betweenvarlow)
    lbl('betweenvarhigh)
    branch
end

block 'betweenvarlow start
    --- X Low High
    unif
    pop
    goto
end

block 'betweenvarhigh start
    --- X Low High
    swap
    int(1)
    add
    swap
    --- X (Low + 1) High
    lbl('between)
    goto
end

block 'betweennonvar start
    --- X Low High
    dup
    nonvar

    dup
    rot
    int(1)
    swap
    sub
    lt

    --- X High
    int(1)
    add
    lt
    goto
end

block 'sum start
    lbl('sumempty)
    lbl('sumcons)
    branch
end

block 'sumempty start
    --- Res X
    swap
    functor('empty, 0)
    unif
    --- Res
    int(0)
    unif
    goto
end

block 'sumcons start
    --- Res Xs
    swap
    fresh
    --- T Xs Res
    dup
    rot
    --- T Xs T Res
    fresh
    --- H T Xs T Res
    dup
    rot
    --- H T H Xs T Res
    functor('cons, 2)
    --- cons(H, T) H Xs T Res
    swap
    rot
    --- cons(H, T) Xs H T Res
    unif

    --- H T Res
    swap
    fresh
    --- TailSum T H Res
    dup
    rot
    --- TailSum T TailSum H Res
    lbl('sumend)
    rot
    --- TailSum T 'sumend TailSum H Res
    lbl('sum)
    goto
end

block 'sumend start
    --- TailSum H Res
    lookup
    swap
    lookup
    swap
    add
    unif
    goto
end

block 'range start
    --- List Low High
    lbl('rangezero)
    lbl('rangenonzero)
    branch
end

block 'rangezero start
    --- List Low High
    rot
    --- Low High List
    swap
    lt
    --- List
    functor('empty, 0)
    --- empty List
    unif
    goto
end

block 'rangenonzero start
    --- List Low High
    rot
    --- Low High List
    dup
    --- Low Low High List
    rot
    --- Low High Low List
    swap
    --- High Low Low List
    dup
    --- High High Low Low List
    rot
    --- High Low High Low List
    swap
    --- Low High High Low List
    lte
    --- High Low List
    rot
    --- Low List High
    dup
    --- Low Low List High
    rot
    --- Low List Low High
    fresh
    --- H Low List Low High
    dup
    rot
    --- H Low H List Low High
    unif
    --- H List Low High
    fresh
    dup
    rot
    --- T H T List Low High
    swap
    functor('cons, 2)
    --- cons(H, T) T List Low High
    rot
    --- T List cons(H, T) Low High
    rot
    --- List cons(H, T) T Low High
    unif
    --- T Low High
    swap
    --- Low T High
    int(1)
    add
    swap
    --- T (Low + 1) High
    lbl('range)
    goto
end

) .

